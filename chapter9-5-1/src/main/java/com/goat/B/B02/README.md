# 总结后就一句话：  装饰者持有被装饰者的引用！！！！！！

# 
     item 05 引子
       比如我们现在有一个歌手大赛，所有的歌手都需要去唱歌。
       但是每一个歌手需要不一样的舞台特效，我们可提供的舞台特效有：伴舞，伴乐，背景大屏幕等。
       比如A歌手需要伴舞，B歌手需要伴奏，C歌手需要伴奏和伴舞，D歌手需要伴奏和背景大屏等等。
       有很多个歌手，有很多个需求
       
# 定义
    装饰者(Decorator)模式提供了一种方法，使得在不改变原有类的基础上可以动态的扩展一个对象的功能。即动态的将指针附加到对象上。
    
    
# 装饰者模式的特点
 
    装饰者（配菜） 继承/实现  被装饰者 （主体）
    1、装饰对象和被装饰对象实现了相同的接口。客户端可以不加区分的使用具体是装饰者实现还是被装饰者实现的接口中的方法。
    2、装饰对象有一个被装饰对象的实例。这样客户端就可以把被装饰对象的实例委托给装饰对象进行数据加工。
    3、装饰对象被创建后，用创建后对象的实例调用接口方法，第一次方法的实现是在被装饰对象内完成。
    4、客户端调用装饰对象无先后顺序。  
    
    
# 具体场景案例
    我们都玩过游戏。游戏中表现人物的情况一般都是用一堆属性来表示，如防御力、攻击力、速度等等。
    拿网游来举例,刚注册游戏时会让我们选择一个具体的角色（法师，弓箭手，武士等），进入游戏后游戏公司一般会赠送几件入门的装备（长剑，法杖，弓箭，鞋子等）。
    游戏的人物可以自由搭配各种装备。
    游戏中具体装备的搭配是有限制的如法师不能使用长剑、弓箭，武士不能使用弓箭、法杖等。为了方便描述在我们这个例子里就不做限制了，同时攻击也不再区分魔法攻击、物理攻击了。
    在游戏这个场景中，我们就可以认为具体的角色（法师，弓箭手，武士等）就是被装饰对象，而装备（长剑，法杖，弓箭，鞋子等）就是装饰对象
    
    如上图定义了IAttribute作为人物属性的接口。接口中定义了getDefense（获取防御力），getPower(获取攻击力) ，getDescribe（获取描述）三个基础方法。
    Mage(法师)、Sagittary(弓箭手)、Warrior（武士）直接实现IAttribute的三个具体的角色。定义了Equip作为装备的基础抽象类实现IAttribute接口。
    Shoe(鞋子)、Bow(弓箭)、Sword(剑)、Wand(法杖)作为具体装备继承自Equip抽象类。
    
    
# 装饰者模式的优缺点：
    优点
    1、装饰对象的添加和撤除非常灵活，客户端可以动态的给被装饰对象添加装饰对象，而且添加的顺序没有要求。
    2、客户端通过使用不同的装饰对象的排列组合，可以设计出多种行为的组合。
    
    的缺点
    1、装饰者模式需要给每个装饰对象建立一个类，当装饰者非常多则会建立很多的装饰着类，会带来程序的碎片化，从而增加程序的复杂度。
    2、装饰者模式非常灵活，这也同时意味着该模式也有着更加多的复杂性。
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    